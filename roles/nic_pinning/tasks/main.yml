# Gather all physical network interfaces except common virtual and bridge types
- name: Get list of physical interfaces
  shell: |
    ls -1 /sys/class/net | grep -vE '^(lo|vmbr|tap|fw|bonding_masters|veth|br|docker|virbr|wg|tun|bond|bridge)'
  register: interfaces_raw
  changed_when: false

# Store interface list for later use
- name: Set interface list
  set_fact:
    interfaces: "{{ interfaces_raw.stdout_lines }}"

- name: Detect interface currently enslaved to vmbr0 (protect Proxmox management NIC)
  shell: |
    for f in /sys/class/net/*; do
      if [ -e "$f/master" ]; then
        master=$(readlink -f "$f/master" 2>/dev/null || true)
        if [ "$(basename "$master")" = "vmbr0" ]; then
          basename "$f"
          exit 0
        fi
      fi
    done
  register: protected_mgmt_iface_raw
  changed_when: false

- name: Set protected management interface fact
  set_fact:
    protected_mgmt_iface: "{{ protected_mgmt_iface_raw.stdout | default('') }}"

- name: Remove protected management interface from interfaces list
  set_fact:
    interfaces: "{{ interfaces | difference([protected_mgmt_iface]) }}"
  when: protected_mgmt_iface is defined and protected_mgmt_iface != ''

# Get supported link modes for each interface (used for naming logic)
- name: Gather Supported link modes for each interface
  shell: |
    ethtool "{{ item }}" | grep 'Supported link modes:' || echo "Supported link modes: Not reported"
  loop: "{{ interfaces }}"
  register: link_modes
  changed_when: false

# Initialize lists for 10G and standard Ethernet interfaces
- name: Initialize xg_ifaces and eth_ifaces
  set_fact:
    xg_ifaces: []
    eth_ifaces: []

# Classify interfaces into 10G (xg_ifaces) and standard Ethernet (eth_ifaces)
- name: Classify interfaces by type
  set_fact:
    xg_ifaces: "{{ xg_ifaces + [item.0] if ('10000baseT' in item.1 and item.0.startswith('ens')) else xg_ifaces }}"
    eth_ifaces: "{{ eth_ifaces + [item.0] if item.0.startswith('eno') else eth_ifaces }}"
  loop: "{{ interfaces | zip(link_modes.results | map(attribute='stdout') | list) | list }}"

# Initialize counters and mapping for custom NIC names
- name: Initialize NIC name counters
  set_fact:
    xg_count: 1
    eth_count: 1
    nic_names: {}

# Assign custom names to each NIC based on type and order (xgN, ethN, nicN)
- name: Assign custom NIC names
  set_fact:
    nic_names: >-
      {{
        nic_names | combine({
          item.0: (
            'xg' ~ xg_count if ('10000baseT' in item.1 and item.0.startswith('ens')) else
            'eth' ~ eth_count if item.0.startswith('eno') else
            'nic' ~ item.2
          )
        })
      }}
    xg_count: "{{ (xg_count | int) + 1 if ('10000baseT' in item.1 and item.0.startswith('ens')) else (xg_count | int) }}"
    eth_count: "{{ (eth_count | int) + 1 if item.0.startswith('eno') else (eth_count | int) }}"
  loop: "{{ interfaces | zip(link_modes.results | map(attribute='stdout') | list) | zip(range(1, interfaces | length + 1)) | map('flatten') | list }}"

# Remove all .link files to ensure a clean state before pinning
- name: Remove all .link files for each NIC (glob, all locations)
  shell: |
    rm -f /usr/local/lib/systemd/network/*.link /etc/systemd/network/*.link /etc/network/*.link
  ignore_errors: true

# Remove any stale /etc/network/interfaces.new before pinning
- name: Remove /etc/network/interfaces.new before pinning
  file:
    path: /etc/network/interfaces.new
    state: absent
  ignore_errors: true

# Generate .link files using pve-network-interface-pinning for each NIC
- name: Generate .link files using pve-network-interface-pinning with custom names
  command: >
    pve-network-interface-pinning generate --interface {{ item }} --target-name {{ nic_names[item] }}
  loop: "{{ interfaces }}"

# Gather MAC address for each interface for systemd .link file creation
- name: Gather MAC address for each interface
  shell: cat /sys/class/net/{{ item }}/address
  loop: "{{ interfaces }}"
  register: mac_info
  changed_when: false

# Create systemd .link files for each NIC, matching by MAC and Type=ether, assigning custom name
# Notifies handlers to update initramfs and restart networking if changed
- name: Generate .link files for each NIC (MAC and Type=ether)
  copy:
    dest: "/etc/systemd/network/10-{{ nic_names[item] }}.link"
    content: |
      [Match]
      MACAddress={{ mac_info.results[idx].stdout }}
      Type=ether
      [Link]
      Name={{ nic_names[item] }}
  loop: "{{ interfaces }}"
  loop_control:
    index_var: idx
  become: true
  notify:
    - update initramfs
    - restart networking

# If a new interfaces file was generated, move it into place
# Notifies handler to restart networking if changed
- name: Update /etc/network/interfaces from .new if present
  shell: |
    if [ -f /etc/network/interfaces.new ]; then
      mv /etc/network/interfaces.new /etc/network/interfaces
    fi
  args:
    executable: /bin/bash
  become: true
  notify:
    - restart networking

- name: Build lists of normalized names by type
  set_fact:
    xg_norm: "{{ nic_names | dict2items | selectattr('value','match','^xg') | map(attribute='value') | list }}"
    eth_norm: "{{ nic_names | dict2items | selectattr('value','match','^eth') | map(attribute='value') | list }}"
    other_norm: "{{ nic_names | dict2items | rejectattr('value','match','^(xg|eth)') | map(attribute='value') | list }}"
  when: nic_names is defined
  tags: [nic_pinning]

- name: Build default bridge_assignments heuristics
  set_fact:
    bridge_assignments: >-
      {{ {
        (mgmt_bridge): ([eth_norm[0]] if (eth_norm | length) > 0 else ([other_norm[0]] if (other_norm | length) > 0 else [])),
        (vm_bridge): (xg_norm | default([])),
        (ext_bridge): ((eth_norm[1:] if (eth_norm | length) > 1 else []) + (other_norm[1:] if (other_norm | length) > 1 else []) )
      } }}
  when: nic_names is defined
  tags: [nic_pinning]

- name: Render suggested provision assignments from nic_pinning
  template:
    src: provision_nic_assignments_from_pinning.j2
    dest: "{{ provision_template_path | default('/tmp/provision_nic_assignments-' ~ inventory_hostname ~ '.yml') }}"
    mode: '0644'
  tags: [nic_pinning]
  when: bridge_assignments is defined and bridge_assignments | length > 0

- name: Gather MAC for protected management interface (if any)
  shell: cat /sys/class/net/{{ protected_mgmt_iface }}/address
  register: protected_mgmt_mac_raw
  changed_when: false
  when: protected_mgmt_iface is defined and protected_mgmt_iface != ''
  tags: [nic_pinning]

- name: Set protected mgmt mac fact
  set_fact:
    protected_mgmt_mac: "{{ protected_mgmt_mac_raw.stdout if protected_mgmt_mac_raw is defined else '' }}"
  when: protected_mgmt_mac_raw is defined
  tags: [nic_pinning]

