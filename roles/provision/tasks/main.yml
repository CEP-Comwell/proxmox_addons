---
---
# Provision role - create three bridges and distribute physical NICs across them
# Behavior / contract:
# - discovers physical NICs on the host (excludes common virtual interfaces)
# - creates three bridges (mgmt/vm/ext) using variables if provided or defaults
# - distributes discovered NICs across the three bridges in round-robin order
# - idempotent: will not re-create bridges if present, will reassign NICs if needed

---
# Provision role - create three bridges and distribute physical NICs across them
# Behavior / contract:
# - discovers physical NICs on the host (excludes common virtual interfaces)
# - creates three bridges (mgmt/vm/ext) using variables if provided or defaults
# - distributes discovered NICs across the three bridges in round-robin order
# - idempotent: will not re-create bridges if present, will reassign NICs if needed

- name: Gather physical network interfaces
  shell: |
    ls -1 /sys/class/net | grep -vE '^(lo|vmbr|tap|fw|bonding_masters|veth|br|docker|virbr|wg|tun|bond|bridge)'
  register: interfaces_raw
  changed_when: false
  tags: [provision]

- name: Set list of physical interfaces
  set_fact:
    interfaces: "{{ interfaces_raw.stdout_lines | default([]) }}"
  tags: [provision]

- name: Set target bridge names (can be overridden by role/play vars)
  set_fact:
    bridges:
      - "{{ mgmt_bridge | default('vmbr99') }}"
      - "{{ vm_bridge | default('vmbr1') }}"
      - "{{ ext_bridge | default('vmbr2') }}"
  tags: [provision]

- name: Show discovered interfaces and bridges
  debug:
    msg: "Found interfaces={{ interfaces }} -> will distribute to bridges={{ bridges }}"
  tags: [provision]

- name: Fail if no physical interfaces found (nothing to assign)
  fail:
    msg: "No physical network interfaces found to provision."
  when: interfaces | length == 0
  tags: [provision]

- name: Ensure each bridge exists (create if missing)
  become: true
  shell: |
    if ! ip link show {{ item }} >/dev/null 2>&1; then
      ip link add name {{ item }} type bridge
    fi
  loop: "{{ bridges }}"
  loop_control:
    label: "{{ item }}"
  tags: [provision]

- name: Initialize bridge assignment map
  set_fact:
    bridge_assignments: {}
  tags: [provision]

- name: Distribute interfaces across bridges (round-robin)
  set_fact:
    bridge_assignments: >-
      {{
        bridge_assignments | combine({ (bridges[(index % (bridges|length))]) : (bridge_assignments.get(bridges[(index % (bridges|length))], []) + [item]) })
      }}
  loop: "{{ interfaces }}"
  loop_control:
    index_var: index
  tags: [provision]

- name: Debug bridge assignments
  debug:
    var: bridge_assignments
  tags: [provision]

- name: Render NIC assignment template (writes a suggested assignment you can edit)
  template:
    src: nic_assignments.j2
    dest: "{{ provision_template_path | default('/tmp/provision_nic_assignments-' ~ inventory_hostname ~ '.yml') }}"
    mode: '0644'
  tags: [provision]

- name: Check for edited NIC assignment template file
  stat:
    path: "{{ provision_template_path | default('/tmp/provision_nic_assignments-' ~ inventory_hostname ~ '.yml') }}"
  register: prov_template_stat
  tags: [provision]

- name: Load edited NIC assignment template if present
  include_vars:
    file: "{{ provision_template_path | default('/tmp/provision_nic_assignments-' ~ inventory_hostname ~ '.yml') }}"
    name: provision_template
  when: prov_template_stat.stat.exists
  tags: [provision]

- name: If template declares a protected management interface, set fact
  set_fact:
    protected_management_interface: "{{ provision_template.protected_management_interface | default('') }}"
    protected_management_mac: "{{ provision_template.protected_management_mac | default('') }}"
  when: prov_template_stat.stat.exists
  tags: [provision]

- name: Build list of interfaces referenced by template (if any)
  set_fact:
    template_assigned_ifaces: >-
      {{ (provision_template.bridge_assignments | default({}) | dict2items | map(attribute='value') | list | flatten) | default([]) }}
  when: prov_template_stat.stat.exists
  tags: [provision]

- name: Find unknown interfaces referenced in template
  set_fact:
    template_unknown_ifaces: "{{ template_assigned_ifaces | difference(interfaces | default([])) }}"
  when: prov_template_stat.stat.exists
  tags: [provision]

- name: Fail if template tries to reassign the protected management interface
  fail:
    msg: "Template attempts to change protected management interface {{ protected_management_interface }}. Remove it from bridge_assignments to avoid losing connectivity."
  when: prov_template_stat.stat.exists and protected_management_interface is defined and (protected_management_interface in (provision_template.bridge_assignments | dict2items | map(attribute='value') | list | flatten))
  tags: [provision]

- name: Fail if template references interfaces not present on host
  fail:
    msg: "Template contains interfaces not present on host: {{ template_unknown_ifaces }}"
  when: prov_template_stat.stat.exists and (template_unknown_ifaces | length > 0)
  tags: [provision]

- name: Use edited template assignments when provided
  set_fact:
    bridge_assignments: "{{ provision_template.bridge_assignments }}"
  when: prov_template_stat.stat.exists
  tags: [provision]

- name: Gather MAC addresses for discovered kernel interfaces
  shell: cat /sys/class/net/{{ item }}/address
  loop: "{{ interfaces }}"
  register: prov_if_mac
  changed_when: false
  tags: [provision]

- name: Build kernel->mac map
  set_fact:
    kernel_to_mac: "{{ dict( prov_if_mac.results | map(attribute='item') | zip( prov_if_mac.results | map(attribute='stdout') ) ) }}"
  when: prov_if_mac is defined
  tags: [provision]

- name: If preferred mgmt specified by MAC, override mgmt_bridge assignment
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({ mgmt_bridge: [ (kernel_to_mac | dict2items | selectattr('value','equalto', provision_preferred_mgmt_mac) | map(attribute='key') | first) ] }) }}"
  when: provision_preferred_mgmt_mac is defined and provision_preferred_mgmt_mac != '' and kernel_to_mac is defined
  tags: [provision]

- name: Validate preferred mgmt MAC exists (fail with available MACs if not found)
  fail:
    msg: "Preferred mgmt MAC {{ provision_preferred_mgmt_mac }} not found on host. Available MACs: {{ kernel_to_mac.values() | list }}"
  when: provision_preferred_mgmt_mac is defined and provision_preferred_mgmt_mac != '' and (kernel_to_mac is defined) and ((kernel_to_mac | dict2items | map(attribute='value') | list) is defined) and (provision_preferred_mgmt_mac not in (kernel_to_mac | dict2items | map(attribute='value') | list))
  tags: [provision]

- name: If preferred mgmt specified by interface name, and present, override mgmt_bridge assignment
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({ mgmt_bridge: [ provision_preferred_mgmt_name ] }) }}"
  when: provision_preferred_mgmt_name is defined and provision_preferred_mgmt_name != '' and (provision_preferred_mgmt_name in interfaces)
  tags: [provision]

- name: Build apply_bridge_assignments (filter to interfaces actually present)
  set_fact:
    apply_bridge_assignments: >-
      {{ dict( bridge_assignments | dict2items | map( {'key': item.key, 'value': (item.value | select('in', interfaces) | reject('equalto', protected_management_interface) | list) } ) | list ) }}
  when: bridge_assignments is defined
  tags: [provision]

- name: Debug apply_bridge_assignments mapping
  debug:
    var: apply_bridge_assignments
  tags: [provision]

- name: Pause for confirmation before applying assignments
  pause:
    prompt: "Proceed to apply bridge assignments? (press Enter to continue or CTRL-C to abort)"
  when: provision_confirm_before_apply | default(false) and not (provision_generate_only | default(false))
  tags: [provision]


 - name: Attach each interface to its bridge
  become: true
  when: not (provision_generate_only | default(false))
  vars:
    iface: "{{ item.1 }}"
    bridge: "{{ item.0 }}"
  loop: "{{ (apply_bridge_assignments | default(bridge_assignments)) | dict2items | subelements('value') }}"
  loop_control:
    label: "{{ bridge }}:{{ iface }}"
  block:
    - name: Get current master of {{ iface }} (if any)
      shell: "readlink -f /sys/class/net/{{ iface }}/master 2>/dev/null || true"
      register: current_master
      changed_when: false

    - name: Detach {{ iface }} from current master if different
      become: true
      shell: |
        if [ -n "{{ current_master.stdout }}" ] && [ "$(basename {{ current_master.stdout }})" != "{{ bridge }}" ]; then
          ip link set dev {{ iface }} nomaster
        fi
      when: current_master.stdout != '' and (current_master.stdout is defined)

    - name: Set {{ iface }} master to {{ bridge }}
      become: true
      shell: |
        # ensure interface is down before enslaving
        ip link set dev {{ iface }} down || true
        ip link set dev {{ iface }} master {{ bridge }}
        ip link set dev {{ bridge }} up
        ip link set dev {{ iface }} up
      args:
        warn: false

  tags: [provision]

- name: Summary - show final state for bridges
  shell: ip -br link show type bridge || true
  register: bridges_state
  changed_when: false
  tags: [provision]

- name: Show bridges state
  debug:
    var: bridges_state.stdout_lines
  tags: [provision]
