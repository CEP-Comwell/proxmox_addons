---
# NEW: Bridge creation and persistence - simplified for fixed architecture
# Fixed bridge assignments for hybrid spine-leaf architecture (1 interface per bridge):
# 10GbE Priority order: vmbr99 (management) > vmbr2 (external) > vmbr1 (VM)
# - vmbr99: Management Bridge (first available 10Gb interface)
# - vmbr2: External Bridge (second 10Gb interface if available, otherwise first 1Gb interface)
# - vmbr1: VM Bridge (third 10Gb interface if available, otherwise next available 1Gb interface)

# Build fixed bridge assignments based on normalized interface names
# Limit to 1 interface per bridge to avoid STP issues
# Priority order for 10GbE: vmbr99 > vmbr2 > vmbr1

- name: Verify required variables are set before proceeding with bridge configuration
  assert:
    that:
      - nic_names is defined
      - protected_mgmt_iface is defined
      - eth_norm is defined
    fail_msg: "Required variables not set. Please run discovery and naming tasks first."

- name: Debug protected management interface
  debug:
    msg: "Protected management interface: {{ protected_mgmt_iface }}"
  when: protected_mgmt_iface is defined

- name: Calculate available 10GbE interfaces (excluding protected)
  set_fact:
    available_10gbe: "{{ nic_names | dict2items | selectattr('value','match','^xg') | map(attribute='key') | select('ne', protected_mgmt_iface) | list }}"

- name: Get normalized names for available 10GbE interfaces
  set_fact:
    available_10gbe_norm: "{{ available_10gbe | map('extract', nic_names) | list }}"

- name: Assign 10GbE interfaces by priority order
  set_fact:
    bridge_assignments:
      vmbr99: "{{ [available_10gbe_norm[0]] if available_10gbe_norm | length > 0 else [] }}"  # Highest priority 10GbE
      vmbr2: "{{ [available_10gbe_norm[1]] if available_10gbe_norm | length > 1 else [] }}"  # Second priority 10GbE
      vmbr1: "{{ [available_10gbe_norm[2]] if available_10gbe_norm | length > 2 else [] }}"  # Third priority 10GbE

- name: Fill 1GbE fallbacks for bridges without 10GbE
  set_fact:
    # Separate eth interfaces from other interfaces and sort eth numerically
    eth_interfaces: "{{ interfaces | select('match', '^eth[0-9]+$') | sort }}"
    other_interfaces: "{{ interfaces | reject('match', '^eth[0-9]+$') | list }}"
    bridges_needing_fallback: "{{ bridge_assignments | dict2items | selectattr('value', 'equalto', []) | map(attribute='key') | list }}"

- name: Create prioritized interface list for fallback assignments
  set_fact:
    # Prioritize eth interfaces first, then other interfaces
    prioritized_interfaces: "{{ eth_interfaces + other_interfaces }}"

- name: Assign fallback interfaces to bridges needing them
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({item.0: [item.1]}) }}"
  loop: "{{ bridges_needing_fallback | zip(prioritized_interfaces) | list }}"
  when: bridges_needing_fallback | length > 0 and prioritized_interfaces | length > 0

# Ensure protected management interface is not assigned to any bridge
- name: Ensure protected management interface is not assigned to any bridge
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({item.key: item.value | reject('equalto', protected_mgmt_iface)}) }}"
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}"

# Validate bridge assignments - ensure exactly 1 interface per bridge
- name: Validate bridge assignments - ensure exactly 1 interface per bridge
  assert:
    that: item.value | length == 1
    fail_msg: "Bridge {{ item.key }} has {{ item.value | length }} interfaces assigned, but exactly 1 interface per bridge is required for SDN stability"
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}: {{ item.value }}"
  when: item.key != 'vmbr0'

# Validate no interface conflicts - ensure each interface is assigned to exactly 1 bridge
- name: Validate no interface conflicts - ensure each interface is assigned to exactly 1 bridge
  set_fact:
    all_assigned_interfaces: "{{ bridge_assignments | dict2items | selectattr('key', 'ne', 'vmbr0') | map(attribute='value') | flatten | list }}"
  when: bridge_assignments is defined

- name: Check for interface conflicts
  assert:
    that: (all_assigned_interfaces | count) == (all_assigned_interfaces | unique | count)
    fail_msg: "Interface conflict detected: {{ all_assigned_interfaces | difference(all_assigned_interfaces | unique) | join(', ') }} are assigned to multiple bridges. Each interface must be assigned to exactly 1 bridge."
  when: all_assigned_interfaces is defined

# Pause for confirmation before applying assignments (if requested)
- name: Pause for confirmation before applying assignments
  pause:
    prompt: "Proceed to apply bridge assignments? (press Enter to continue or CTRL-C to abort)"
  when: provision_confirm_before_apply | default(false) and not (provision_generate_only | default(false))

# Ensure each bridge exists (create if missing)
- name: Ensure each bridge exists (create if missing)
  become: true
  shell: |
    if ! ip link show {{ item }} >/dev/null 2>&1; then
      ip link add name {{ item }} type bridge
    fi
  loop: "{{ bridge_assignments | list }}"
  loop_control:
    label: "{{ item }}"
  when: not (provision_generate_only | default(false))

# Clean up unmanaged interfaces from bridges
- name: Clean up unmanaged interfaces from bridges
  become: true
  when: not (provision_generate_only | default(false))
  shell: |
    # Get all interfaces currently attached to this bridge
    current_interfaces=$(ip link show master {{ item.key }} 2>/dev/null | awk '/^[0-9]+:/ {gsub(/[:@].*/, "", $2); print $2}' || true)
    
    # Check each current interface
    for iface in $current_interfaces; do
      # If interface is not in the desired list for this bridge, detach it
      if ! echo "{{ item.value | join(' ') }}" | grep -q "\\b$iface\\b"; then
        echo "Detaching unmanaged interface $iface from {{ item.key }}"
        ip link set dev $iface nomaster || true
        ip link set dev $iface down || true
      fi
    done
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}"

# Attach each interface to its bridge
- name: Attach each interface to its bridge
  become: true
  when: not (provision_generate_only | default(false))
  loop: "{{ bridge_assignments | dict2items | subelements('value') }}"
  loop_control:
    label: "{{ item.0.key }}:{{ item.1 }}"
  vars:
    bridge: "{{ item.0.key }}"
    iface: "{{ item.1 }}"
  shell: |
    current_master="$(readlink -f /sys/class/net/{{ iface }}/master 2>/dev/null || true)"
    if [ -n "$current_master" ] && [ "$(basename "$current_master")" != "{{ bridge }}" ]; then
      ip link set dev {{ iface }} nomaster || true
    fi
    # ensure interface is down before enslaving
    ip link set dev {{ iface }} down || true
    ip link set dev {{ iface }} master {{ bridge }} || true
    ip link set dev {{ bridge }} up || true
    ip link set dev {{ iface }} up || true

# Persist bridge configuration to /etc/network/interfaces.d/
- name: Persist bridge configuration to /etc/network/interfaces.d/
  become: true
  when: not (provision_generate_only | default(false))
  template:
    src: interfaces-bridges.j2
    dest: /etc/network/interfaces.d/ansible-bridges
    mode: '0644'

# Reload network configuration for PVE 9 SDN compatibility
- name: Reload network configuration for PVE 9 SDN compatibility
  become: true
  when: not (provision_generate_only | default(false))
  command: ifreload -a
  changed_when: true

# Note: Removed direct modification of /etc/network/interfaces to follow proper sourcing practices
# Proxmox GUI should still display bridges if they are active in the system

# Summary - show final state for bridges
- name: Summary - show final state for bridges
  shell: ip -br link show type bridge || true
  register: bridges_state
  changed_when: false

- name: Show bridges state
  debug:
    var: bridges_state.stdout_lines
