---
# Inventory-driven bridge configuration for Proxmox VE
# Engineers describe bridge topology in group_vars/host_vars using the
# `bridges` list. Each item should at minimum define a bridge `name` and
# `bridge_ports` (use an empty list when the bridge has no physical uplinks).
#
# Example:
# bridges:
#   - name: vmbr99
#     bridge_ports:
#       - ens1f0
#     vlan_aware: true
#   - name: vmbr2
#     bridge_ports: []

- name: Ensure bridge definitions exist in inventory
  assert:
    that:
      - bridges is defined
      - bridges | length > 0
    fail_msg: >-
      Define `bridges` as a non-empty list in inventory (see group_vars/all.yml
      for examples) before running the network_provision role.

- name: Ensure each bridge definition includes a name
  assert:
    that:
      - item.name is defined
      - (item.name | string | trim | length) > 0
    fail_msg: "Bridge definition at index {{ bridge_idx }} is missing a 'name'."

  loop: "{{ bridges }}"
  loop_control:
    index_var: bridge_idx
    label: "{{ item.name | default('undefined') }}"

- name: Ensure bridge names are unique
  vars:
    bridge_names: "{{ bridges | map(attribute='name') | list }}"
  assert:
    that:
      - bridge_names | length == bridge_names | unique | length
    fail_msg: "Duplicate bridge names detected in the 'bridges' inventory list."

- name: Ensure bridge ports are declared (use [] for none)
  assert:
    that:
      - item.bridge_ports is defined
    fail_msg: "Bridge {{ item.name }} must define bridge_ports (empty list allowed)."
  loop: "{{ bridges }}"
  loop_control:
    label: "{{ item.name }}"

- name: Validate subinterface definitions (if provided)
  assert:
    that:
      - child.name is defined
      - (child.name | string | trim | length) > 0
      - child.type is defined
    fail_msg: "Subinterface declarations must include both 'name' and 'type'."
  vars:
    child: "{{ item.1 }}"
  loop: "{{ bridges | subelements('subinterfaces', skip_missing=True) }}"
  loop_control:
    label: "{{ item.1.name | default('undefined') }}"

- name: Initialize normalized bridge and subinterface lists
  set_fact:
    normalized_bridges: []
    normalized_subinterfaces: []

- name: Normalize bridge definitions from inventory
  set_fact:
    normalized_bridges: "{{ normalized_bridges + [ {
      'name': item.name,
      'ports': ports_list,
      'ports_arg': ports_list | join(','),
      'ports_param': (item.type | default('bridge')) == 'OVSBridge' and 'ovs_ports' or 'bridge_ports',
      'bridge_type': item.type | default('bridge'),
      'autostart': (item.autostart | default(true) | bool),
      'vlan_aware': (item.vlan_aware | default(item.name not in ['vmbr0']) | bool),
      'mtu': item.mtu | default(''),
      'comment': item.comment | default(''),
      'ovs_options': item.ovs_options | default(''),
      'ovs_mtu': item.ovs_mtu | default('')
    } ] }}"
  vars:
    ports_list: >-
      {{
        item.bridge_ports
        if item.bridge_ports is defined and item.bridge_ports is iterable and item.bridge_ports is not string
        else (item.bridge_ports | default('') | regex_replace('[, ]+', ' ') | trim | split())
      }}
  loop: "{{ bridges }}"
  loop_control:
    label: "{{ item.name }}"

- name: Normalize declared subinterfaces
  set_fact:
    normalized_subinterfaces: "{{ normalized_subinterfaces + [ {
      'parent_bridge': parent.name,
      'name': child.name,
      'type': child.type,
      'autostart': (child.autostart | default(true) | bool),
      'comment': child.comment | default(''),
      'options': (
        default_bridge_option | combine(default_link_option) | combine(child.options | default({}))
      )
    } ] }}"
  vars:
    parent: "{{ item.0 }}"
    child: "{{ item.1 }}"
    child_type_lower: "{{ child.type | default('') | lower }}"
    has_bridge_option: "{{ child.options is defined and child.options is mapping and ('bridge' in child.options) }}"
    has_link_option: "{{ child.options is defined and child.options is mapping and ('link' in child.options or 'link0' in child.options) }}"
    default_bridge_option: "{{ {} if has_bridge_option else {'bridge': parent.name} }}"
    default_link_option: "{{ {'link': parent.name} if child_type_lower == 'vlan' and not has_link_option else {} }}"
  loop: "{{ bridges | subelements('subinterfaces', skip_missing=True) }}"
  loop_control:
    label: "{{ item.1.name | default('undefined') }}"

- name: Build list of known interface identifiers
  set_fact:
    known_interfaces: "{{ ((all_interfaces | default([]))
      + (nic_names | default({}) | dict2items | map(attribute='value') | list)
      + (normalized_subinterfaces | map(attribute='name') | list)) | unique }}"

- name: Validate bridge types are supported
  assert:
    that:
      - item.bridge_type in ['bridge', 'OVSBridge']
    fail_msg: "Bridge {{ item.name }} uses unsupported type '{{ item.bridge_type }}'."
  loop: "{{ normalized_bridges }}"
  loop_control:
    label: "{{ item.name }}"

- name: Validate bridge ports exist on host (when discoverable)
  assert:
    that:
      - missing_ports | length == 0
    fail_msg: >-
      Bridge {{ item.name }} references unknown interfaces: {{ missing_ports | join(', ') }}.
      Available interfaces: {{ known_interfaces | default([]) | join(', ') }}
  vars:
    missing_ports: "{{ item.ports | difference(known_interfaces | default([])) }}"
  loop: "{{ normalized_bridges }}"
  loop_control:
    label: "{{ item.name }}"
  when:
    - item.ports | length > 0
    - known_interfaces is defined

- name: Pause for confirmation before applying bridge configuration
  pause:
    prompt: "Proceed to apply bridge configuration? (press Enter to continue or CTRL-C to abort)"
  when: provision_confirm_before_apply | default(false) and not (provision_generate_only | default(false))

- name: Get current Proxmox network configuration
  become: true
  command: pvesh get /nodes/localhost/network --output-format json
  register: proxmox_network_config
  changed_when: false
  when: not (provision_generate_only | default(false))
  check_mode: no

- name: Parse existing network interfaces
  set_fact:
    existing_interfaces: "{{ proxmox_network_config.stdout | from_json | map(attribute='iface') | list }}"
  when: not (provision_generate_only | default(false)) and proxmox_network_config.stdout is defined
  check_mode: no

- name: Create or update bridges using Proxmox API
  become: true
  when: not (provision_generate_only | default(false))
  loop: "{{ normalized_bridges }}"
  loop_control:
    label: "{{ item.name }}"
  vars:
    autostart_flag: "{{ item.autostart | ternary('yes', 'no') }}"
    include_vlan: "{{ item.bridge_type == 'bridge' }}"
    vlan_flag: "{{ item.vlan_aware | ternary('yes', 'no') }}"
    has_ports: "{{ (item.ports_arg | length) > 0 }}"
    mtu_arg: "{{ item.mtu | string | trim }}"
    comment_arg: "{{ item.comment | string | trim }}"
    ovs_opts_arg: "{{ item.ovs_options | string | trim }}"
    ovs_mtu_arg: "{{ item.ovs_mtu | string | trim }}"
  shell: |
    set -euo pipefail
    bridge_name="{{ item.name }}"
    declare -a set_args
    declare -a create_args
    set_args=(-type "{{ item.bridge_type }}")
    create_args=(-iface "{{ item.name }}" -type "{{ item.bridge_type }}")
    set_args+=(-autostart "{{ autostart_flag }}")
    create_args+=(-autostart "{{ autostart_flag }}")
    {% if include_vlan | bool %}
    set_args+=(-bridge_vlan_aware "{{ vlan_flag }}")
    create_args+=(-bridge_vlan_aware "{{ vlan_flag }}")
    {% endif %}
    {% if has_ports | bool %}
    set_args+=(-{{ item.ports_param }} "{{ item.ports_arg }}")
    create_args+=(-{{ item.ports_param }} "{{ item.ports_arg }}")
    {% endif %}
    {% if mtu_arg %}
    set_args+=(-mtu "{{ mtu_arg }}")
    create_args+=(-mtu "{{ mtu_arg }}")
    {% endif %}
    {% if item.bridge_type == 'OVSBridge' and ovs_mtu_arg %}
    set_args+=(-ovs_mtu "{{ ovs_mtu_arg }}")
    create_args+=(-ovs_mtu "{{ ovs_mtu_arg }}")
    {% endif %}
    {% if comment_arg %}
    set_args+=(-comments "{{ comment_arg }}")
    create_args+=(-comments "{{ comment_arg }}")
    {% endif %}
    {% if item.bridge_type == 'OVSBridge' and ovs_opts_arg %}
    set_args+=(-ovs_options "{{ ovs_opts_arg }}")
    create_args+=(-ovs_options "{{ ovs_opts_arg }}")
    {% endif %}
    if /usr/bin/jq -r '.[].iface' < <(pvesh get /nodes/localhost/network --output-format json) | grep -q "^${bridge_name}$"; then
      pvesh set /nodes/localhost/network/${bridge_name} "${set_args[@]}"
    else
      pvesh create /nodes/localhost/network "${create_args[@]}"
    fi
  args:
    executable: /bin/bash

- name: Ensure interfaces referenced in bridges are declared
  become: true
  when: not (provision_generate_only | default(false))
  loop: "{{ normalized_bridges | subelements('ports') }}"
  loop_control:
    label: "{{ item.1 }}"
  vars:
    iface: "{{ item.1 }}"
  command: |
    bash -c "
    if ! /usr/bin/jq -r '.[].iface' < <(pvesh get /nodes/localhost/network --output-format json) | grep -q '^\\b{{ iface }}\\b$'; then
      pvesh create /nodes/localhost/network -iface {{ iface }} -type eth
    fi
    "

- name: Create or update bridge sub-interfaces
  become: true
  when:
    - not (provision_generate_only | default(false))
    - normalized_subinterfaces | length > 0
  loop: "{{ normalized_subinterfaces }}"
  loop_control:
    label: "{{ item.name }}"
  vars:
    autostart_flag: "{{ item.autostart | ternary('yes', 'no') }}"
    comment_arg: "{{ item.comment | string | trim }}"
  shell: |
    set -euo pipefail
    iface_name="{{ item.name }}"
    declare -a set_args
    declare -a create_args
    set_args=(-type "{{ item.type }}")
    create_args=(-iface "{{ item.name }}" -type "{{ item.type }}")
    set_args+=(-autostart "{{ autostart_flag }}")
    create_args+=(-autostart "{{ autostart_flag }}")
    {% if comment_arg %}
    set_args+=(-comments "{{ comment_arg }}")
    create_args+=(-comments "{{ comment_arg }}")
    {% endif %}
    {% for opt in (item.options | default({}) | dict2items) %}
    {% set opt_value = opt.value %}
    {% if opt_value is iterable and opt_value is not string %}
    {% set opt_value = opt_value | join(',') %}
    {% endif %}
    set_args+=(-{{ opt.key }} "{{ opt_value }}")
    create_args+=(-{{ opt.key }} "{{ opt_value }}")
    {% endfor %}
    if /usr/bin/jq -r '.[].iface' < <(pvesh get /nodes/localhost/network --output-format json) | grep -q "^${iface_name}$"; then
      pvesh set /nodes/localhost/network/${iface_name} "${set_args[@]}"
    else
      pvesh create /nodes/localhost/network "${create_args[@]}"
    fi
  args:
    executable: /bin/bash

- name: Reload network configuration
  become: true
  when: not (provision_generate_only | default(false))
  command: pvesh set /nodes/localhost/network
  changed_when: true
  register: network_reload_result

- name: Summary - show final state for bridges
  shell: ip -br link show type bridge || true
  register: bridges_state
  changed_when: false

- name: Show bridges state
  debug:
    var: bridges_state.stdout_lines

- name: Show Proxmox network configuration
  become: true
  command: pvesh get /nodes/localhost/network
  register: final_proxmox_config
  changed_when: false

- name: Display final Proxmox network configuration
  debug:
    msg: "{{ final_proxmox_config.stdout_lines | join('\n') }}"

- name: Reboot system to apply network changes
  reboot:
    reboot_timeout: 300
    msg: "Rebooting system to apply network configuration changes"
  when: provision_reboot_after_config | default(false)
  register: reboot_result

- name: Wait for system to stabilize after reboot
  command: sleep 160
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Verify bridges are active after reboot
  command: ip -br link show type bridge
  register: post_reboot_bridges
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Verify Proxmox network configuration after reboot
  become: true
  command: pvesh get /nodes/localhost/network
  register: post_reboot_config
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Display post-reboot verification results
  debug:
    msg: |
      === Post-Reboot Network Verification ===
      Bridge Status:
      {{ post_reboot_bridges.stdout_lines | join('\n') }}

      Proxmox Network Configuration:
      {{ post_reboot_config.stdout_lines | join('\n') }}

      âœ… Network configuration successfully applied and verified after reboot!
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
