---
# Simplified bridging tasks (single-file orchestration)
#
# Purpose
# - Provide a compact flow for rendering and (optionally) applying both OVS
#   and Linux bridge configuration for a single host.
#
# Notes for junior engineers
# - This file mirrors the main `bridging.yml` flow but keeps the tasks
#   simpler and more explicit for quick runs. It still delegates normalization
#   to `normalize_ovs.yml` and prefers Proxmox `pvesh` for Linux bridge actions.

- name: Load host-specific OVS vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/bridges.yml"
    name: ovs_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Load host-specific network vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/network.yml"
    name: net_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Merge bridges from host vars and role/group `bridges`
  set_fact:
    merged_bridges: >-
      {{ (ovs_host_vars.bridges | default([])) + (net_host_vars.bridges | default([])) + (bridges | default([])) }}
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Validate all bridge and subinterface names (fail-fast for invalid names)
  assert:
    that:
      - "(all_iface_names | map('regex_search', '^[A-Za-z0-9._]+$') | list | length) == (all_iface_names | length)"
    fail_msg: "One or more interface/subinterface names are invalid for Proxmox API. Names must match ^[A-Za-z0-9._]+$. Offending: {{ all_iface_names | reject('regex_search','^[A-Za-z0-9._]+$') | list }}"
  vars:
    all_bridge_names: "{{ (ovs_host_vars.bridges | default([])) + (net_host_vars.bridges | default([])) + (bridges | default([])) | map(attribute='name') | list }}"
    all_sub_names: >-
      {{ ((ovs_host_vars.bridges | default([])) + (net_host_vars.bridges | default([])) + (bridges | default([])))
         | map(attribute='subinterfaces') | select('defined') | list | sum(start=[]) | map(attribute='name') | list }}
    all_iface_names: "{{ (all_bridge_names + all_sub_names) | select('defined') | list }}"
  when: ( (ovs_host_vars.bridges | default([])) or (net_host_vars.bridges | default([])) or (bridges | default([])) )
  tags:
    - deploy_linux_bridges

- name: Initialize normalized_bridges
  set_fact:
    normalized_bridges: []
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Normalize each bridge entry (interface and type)
  set_fact:
    normalized_bridges: >-
      {{ normalized_bridges + [ (
        item | combine({
          'ports': (item.ports | default(item.bridge_ports | default([]))),
          'interface': ((item.ports | default(item.bridge_ports | default([])))[0] if ((item.ports | default(item.bridge_ports | default([]))) | length > 0) else (item.parent | default(item.interface | default('')))),
          'type': ( 'ovs' if ('ovs' in (item.type | default('bridge') | string | lower)) else 'bridge' )
        })
      ) ] }}
  loop: "{{ merged_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Split into ovs_bridges and linux_bridges
  set_fact:
    ovs_bridges: "{{ normalized_bridges | selectattr('type','equalto','ovs') | list }}"
    linux_bridges: "{{ normalized_bridges | selectattr('type','equalto','bridge') | list }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize unique linux_bridges list
  set_fact:
    linux_bridges_unique: []
  tags:
    - deploy_linux_bridges

- name: Build unique linux_bridges by name (deduplicate duplicates from host_vars)
  set_fact:
    linux_bridges_unique: "{{ linux_bridges_unique + [ item ] }}"
  loop: "{{ linux_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  when: "(linux_bridges_unique | map(attribute='name') | list).count(item.name) == 0"
  tags:
    - deploy_linux_bridges

# OVS flow (simplified)
# - Build the `ovs_bridge_block` from `ovs_bridges` facts.
# - Remove any duplicate Linux bridge stanzas for interfaces that will be
#   managed by OVS (so there's no conflict in `/etc/network/interfaces`).
- name: Build OVS /etc/network/interfaces block
  set_fact:
    ovs_bridge_block: "{{ lookup('template', playbook_dir + '/../../roles/network_provision/templates/ovs_bridges.j2') }}"
  when: ovs_bridges | length > 0
  changed_when: false
  tags:
    - deploy_ovs_bridges

- name: Remove existing Linux bridge stanzas for OVS-named bridges
  become: true
  shell: |
    for br in {{ ovs_bridges | map(attribute='name') | join(' ') }}; do
      perl -0777 -i -pe "s/\nauto ${br}[\\s\\S]*?(?=\nauto |\n# BEGIN |\nsource )//g" /etc/network/interfaces || true
    done
  when: ovs_bridges | length > 0
  tags:
    - deploy_ovs_bridges

- name: Normalize any existing OVS blocks and ensure spacing between iface stanzas
  include_tasks: normalize_ovs.yml
  # Normalization is intentionally a separate, included task file so both
  # flows share the same backing logic and safety checks.
  tags:
    - deploy_ovs_bridges

- name: Insert OVS block into /etc/network/interfaces (above source include)
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} OVS BRIDGES"
    block: "{{ ovs_bridge_block }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  notify: reload_network
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Show OVS bridge block (no host edits)
  debug:
    msg: "{{ ovs_bridge_block }}"
  when: (ovs_bridges | length > 0) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Create OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-br {{ item.name }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0)
  tags:
    - deploy_ovs_bridges

- name: Add ports to OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-port {{ item.name }} {{ item.interface }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.interface is defined and item.interface != '')
  tags:
    - deploy_ovs_bridges

- name: Set OVS port MTU (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl set Interface {{ item.interface }} mtu_request={{ item.mtu }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.mtu is defined and item.mtu | int > 0) and (item.interface is defined and item.interface != '')
  tags:
    - deploy_ovs_bridges

### Linux bridge tasks (tag: deploy_linux_bridges)

# Discover Proxmox node id and existing network objects so we can be idempotent
- name: Get Proxmox nodes (for node id resolution)
  become: true
  command: pvesh --noproxy get /nodes --output-format json
  register: pvesh_nodes_raw
  changed_when: false
  tags:
    - deploy_linux_bridges

- name: Set pve_node_id (first node)
  set_fact:
    pve_node_id: "{{ (pvesh_nodes_raw.stdout | from_json)[0].node }}"
  when: pvesh_nodes_raw.stdout is defined and (pvesh_nodes_raw.stdout | default('') | trim) != ''
  tags:
    - deploy_linux_bridges

- name: Get existing network objects for node
  become: true
  command: "pvesh --noproxy get /nodes/{{ pve_node_id }}/network --output-format json"
  register: pvesh_networks_raw
  changed_when: false
  when: pve_node_id is defined
  tags:
    - deploy_linux_bridges

- name: Set existing_ifaces list
  set_fact:
    existing_networks: "{{ pvesh_networks_raw.stdout | default('[]') | from_json }}"
    existing_ifaces: "{{ (pvesh_networks_raw.stdout | default('[]') | from_json) | map(attribute='iface') | list }}"
  when: pvesh_networks_raw is defined
  tags:
    - deploy_linux_bridges

# Per-bridge existence check in Proxmox: this avoids pvesh create errors when
# an iface already exists (but may not have been present in the earlier
# aggregated listing). We register a list of results in
# `pvesh_iface_lookup.results` and reference by loop index below.
- name: Check if bridge iface exists in Proxmox
  become: true
  command: >-
    pvesh --noproxy get /nodes/{{ pve_node_id }}/network/{{ item.name }} --output-format json
  register: pvesh_iface_lookup
  failed_when: false
  changed_when: false
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  when: pve_node_id is defined and (linux_bridges | length > 0)
  tags:
    - deploy_linux_bridges

  # create missing bridges
- name: Create linux bridges (when missing)
  become: true
  vars:
    _existing: >-
      {{ (pvesh_networks_raw.stdout | default('[]') | from_json) | selectattr('iface','equalto', item.name) | list | first | default({}) }}
     # only include flags with non-empty values to avoid pvesh "too many arguments"
     _create_params: >-
      {{ ['--iface', item.name | default(''), '--type', 'bridge']
        + (['--bridge_ports', item.interface] if (item.interface is defined and (item.interface | string) | length > 0) else [])
        + (['--address', item.address] if (item.address is defined and (item.address | string) | length > 0) else [])
        + (['--mtu', item.mtu|string] if (item.mtu is defined and (item.mtu|string) | length > 0) else [])
      }}
  command: >-
    pvesh --noproxy create /nodes/{{ pve_node_id }}/network {{ _create_params | join(' ') }}
  register: pvesh_create_result
  when: pve_node_id is defined and (linux_bridges_unique | default(linux_bridges) | length > 0) and (pvesh_iface_lookup is defined and (pvesh_iface_lookup.results[iface_idx].rc | default(0)) != 0)
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  failed_when: false
  tags:
    - deploy_linux_bridges

- name: Validate linux bridge iface name for pvesh create
  assert:
    that:
      - "(item.name is match('^[A-Za-z0-9._]+$'))"
    fail_msg: "Invalid iface name '{{ item.name }}' for Proxmox API. Rename or adjust the host var before creating via pvesh."
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  when: pve_node_id is defined and (linux_bridges | length > 0) and (pvesh_iface_lookup is defined and (pvesh_iface_lookup.results[iface_idx].rc | default(0)) != 0)
  tags:
    - deploy_linux_bridges

- name: Validate linux bridge iface name for pvesh create
  # (removed - validation is run earlier to prevent pvesh create calls with invalid names)

- name: 'Fallback: reconcile iface when create failed with "interface already exists"'
  become: true
  vars:
    _existing: >-
      {{ (pvesh_networks_raw.stdout | default('[]') | from_json) | selectattr('iface','equalto', item.name) | list | first | default({}) }}
    _set_params: >-
      {{ []
        + (['--mtu', item.mtu|string] if (item.mtu is defined and ((_existing.mtu | default('')) | string != (item.mtu | string))) else [])
        + (['--address', item.address] if (item.address is defined and ((_existing.cidr | default('')) != (item.address))) else [])
        + (['--bridge_ports', item.interface] if (item.interface is defined and ((_existing.bridge_ports | default('')) | string != (item.interface | string))) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_create_fallback_result
  failed_when: false
  when: >-
    pve_node_id is defined and
    (pvesh_create_result is defined) and
    ((pvesh_create_result.results[iface_idx].rc | default(0)) != 0) and
    ("interface already exists" in (pvesh_create_result.results[iface_idx].stderr | default(''))) and
    (_set_params | length > 0)
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  tags:
    - deploy_linux_bridges

- name: Set linux bridges (update existing when diffs)
  become: true
  vars:
    _existing: >-
      {{ (pvesh_networks_raw.stdout | default('[]') | from_json) | selectattr('iface','equalto', item.name) | list | first | default({}) }}
    _set_params: >-
      {{ []
        + (['--mtu', item.mtu|string] if (item.mtu is defined and ((_existing.mtu | default('')) | string != (item.mtu | string))) else [])
        + (['--address', item.address] if (item.address is defined and ((_existing.cidr | default('')) != (item.address))) else [])
        + (['--bridge_ports', item.interface] if (item.interface is defined and ((_existing.bridge_ports | default('')) | string != (item.interface | string))) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_set_result
  when: pve_node_id is defined and (linux_bridges_unique | default(linux_bridges) | length > 0) and (pvesh_iface_lookup is defined and (pvesh_iface_lookup.results[iface_idx].rc | default(1)) == 0) and (_set_params | length > 0)
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  failed_when: false
  tags:
    - deploy_linux_bridges

- name: Record no-op for linux bridges that already match desired state
  set_fact:
    pvesh_noop: true
  vars:
    _existing: >-
      {{ (pvesh_networks_raw.stdout | default('[]') | from_json) | selectattr('iface','equalto', item.name) | list | first | default({}) }}
    _set_params: >-
      {{ []
        + (['--mtu', item.mtu|string] if (item.mtu is defined and ((_existing.mtu | default('')) | string != (item.mtu | string))) else [])
        + (['--address', item.address] if (item.address is defined and ((_existing.cidr | default('')) != (item.address))) else [])
        + (['--bridge_ports', item.interface] if (item.interface is defined and ((_existing.bridge_ports | default('')) | string != (item.interface | string))) else [])
      }}
  when: pve_node_id is defined and (linux_bridges_unique | default(linux_bridges) | length > 0) and (pvesh_iface_lookup is defined and (pvesh_iface_lookup.results[iface_idx].rc | default(1)) == 0) and (_set_params | length == 0)
  loop: "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
    index_var: iface_idx
  tags:
    - deploy_linux_bridges

- name: Show pvesh create results (if any)
  debug:
    var: pvesh_create_result
  when: pvesh_create_result is defined
  tags:
    - deploy_linux_bridges

- name: Show pvesh set results (if any)
  debug:
    var: pvesh_set_result
  when: pvesh_set_result is defined
  tags:
    - deploy_linux_bridges

- name: Show pvesh no-op marker (if any)
  debug:
    var: pvesh_noop
  when: pvesh_noop is defined
  tags:
    - deploy_linux_bridges

### Subinterfaces (VLANs) provisioning

- name: Build flattened list of bridge subinterfaces (parent + sub)
  set_fact:
    bridge_subinterfaces: "{{ bridge_subinterfaces | default([]) + [ {'parent': item.0.name, 'name': item.1.name, 'options': item.1, 'type': item.1.type | default('vlan')} ] }}"
  with_subelements:
    - "{{ linux_bridges_unique | default(linux_bridges) | default([]) }}"
    - subinterfaces
  loop_control:
    label: "{{ item.1.name | default('unnamed') }}"
  when: linux_bridges_unique is defined
  tags:
    - deploy_linux_bridges

- name: Check if subinterface exists in Proxmox
  become: true
  command: >-
    pvesh --noproxy get /nodes/{{ pve_node_id }}/network/{{ item.name }} --output-format json
  register: pvesh_subiface_lookup
  failed_when: false
  changed_when: false
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0)
  tags:
    - deploy_linux_bridges

- name: Validate subinterface iface name for pvesh create
  assert:
    that:
      - "(item.name is match('^[A-Za-z0-9._]+$'))"
    fail_msg: "Invalid subinterface name '{{ item.name }}' for Proxmox API. Rename or adjust the host var before creating via pvesh."
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(0)) != 0)
  tags:
    - deploy_linux_bridges

- name: Create subinterfaces (when missing)
  become: true
  vars:
    # support either nested 'options' key or flat subinterface dict
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    # build flags as single "--flag=value" strings so empty values are never left as a bare flag
    _create_params: >-
      {{ ["--iface=" ~ item.name, "--type=" ~ (item.type | default('vlan'))]
         + (
           (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
         )
         + (
           (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0) ) else [])
         )
         + (
           (['--cidr=' ~ _opts.address])
           if (_opts.address is defined and ('/' in (_opts.address | string)))
           else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else [])
         )
         + (
           (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
         )
      }}
  command: >-
    pvesh --noproxy create /nodes/{{ pve_node_id }}/network {{ _create_params | join(' ') }}
  register: pvesh_subiface_create
  failed_when: false
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(0)) != 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: 'Fallback: reconcile subiface when create failed with "interface already exists"'
  become: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    _set_params: >-
      {{ ["--type=" ~ (item.type | default('vlan'))]
        + (
          (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
        )
        + (
          (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0)) else [])
        )
        + (['--cidr=' ~ _opts.address] if (_opts.address is defined and ('/' in (_opts.address | string))) else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else []))
        + (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_subiface_create_fallback_result
  failed_when: false
  when: >-
    pve_node_id is defined and
    (pvesh_subiface_create is defined) and
    ((pvesh_subiface_create.results[sub_idx].rc | default(0)) != 0) and
    ("interface already exists" in (pvesh_subiface_create.results[sub_idx].stderr | default(''))) and
    (_set_params | length > 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: Set subinterfaces (update existing when diffs)
  become: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    _set_params: >-
      {{ []
        + (
          (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
        )
        + (
          (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0)) else [])
        )
        + (['--cidr=' ~ _opts.address] if (_opts.address is defined and ('/' in (_opts.address | string))) else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else []))
        + (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_subiface_set
  failed_when: false
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(1)) == 0) and (_set_params | length > 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: Record no-op for subinterfaces that already match desired state
  set_fact:
    pvesh_subiface_noop: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _set_params: >-
      {{ []
        + (['--vlan-id', _vlan_id|string] if (_vlan_id is defined and _vlan_id is not none) else [])
        + (['--vlan-raw-device', _vlan_raw] if (_vlan_raw is defined and _vlan_raw | length > 0) else [])
        + (['--address', _opts.address] if (_opts.address is defined) else [])
      }}
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(1)) == 0) and (_set_params | length == 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

# Ensure source directive and validate
- name: Ensure source directive at end of interfaces
  become: true
  lineinfile:
    path: /etc/network/interfaces
    line: "source /etc/network/interfaces.d/*"
    insertafter: EOF

# Fallback: write /etc/network/interfaces.d/<iface>.cfg when pvesh not available
# or when explicitly requested by write_interfaces_file.
- name: Write Linux bridge interface files (fallback)
  become: true
  vars:
    bridge: "{{ item }}"
  template:
    src: linux_bridges_interfaces.j2
    dest: "/etc/network/interfaces.d/{{ item.name }}.cfg"
    owner: root
    group: root
    mode: '0644'
  loop: "{{ (linux_bridges_unique | default(linux_bridges) | default([])) }}"
  loop_control:
    label: "{{ item.name }}"
  # only write fallback interface files when explicitly requested, when we have
  # a resolved pve_node_id (to avoid accidental writes in check-mode or when
  # pvesh is unavailable), and not when Ansible is running in check mode.
  when: (write_interfaces_file | default(false)) and (pve_node_id is defined) and (not (ansible_check_mode | default(false)))
  tags:
    - deploy_linux_bridges

- name: Validate /etc/network/interfaces via ifquery
  command: ifquery --list
  register: ifquery_result
  failed_when: ifquery_result.rc != 0
  changed_when: false

---
# Simplified bridging tasks (single-file orchestration)
#
# Purpose
# - Provide a compact flow for rendering and (optionally) applying both OVS
#   and Linux bridge configuration for a single host.
#
# Notes for junior engineers
# - This file mirrors the main `bridging.yml` flow but keeps the tasks
#   simpler and more explicit for quick runs. It still delegates normalization
#   to `normalize_ovs.yml` and prefers Proxmox `pvesh` for Linux bridge actions.

- name: Load host-specific OVS vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/bridges.yml"
    name: ovs_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Load host-specific network vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/network.yml"
    name: net_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Merge bridges from host vars and role/group `bridges`
  set_fact:
    merged_bridges: >-
      {{ (ovs_host_vars.bridges | default([])) + (net_host_vars.bridges | default([])) + (bridges | default([])) }}
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize normalized_bridges
  set_fact:
    normalized_bridges: []
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Normalize each bridge entry (interface and type)
  set_fact:
    normalized_bridges: >-
      {{ normalized_bridges + [ (
        item | combine({
          'ports': (item.ports | default(item.bridge_ports | default([]))),
          'interface': ((item.ports | default(item.bridge_ports | default([])))[0] if ((item.ports | default(item.bridge_ports | default([]))) | length > 0) else (item.parent | default(item.interface | default('')))),
          'type': ( 'ovs' if ('ovs' in (item.type | default('bridge') | string | lower)) else 'bridge' )
        })
      ) ] }}
  loop: "{{ merged_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Split into ovs_bridges and linux_bridges
  set_fact:
    ovs_bridges: "{{ normalized_bridges | selectattr('type','equalto','ovs') | list }}"
    linux_bridges: "{{ normalized_bridges | selectattr('type','equalto','bridge') | list }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize unique linux_bridges list
  set_fact:
    linux_bridges_unique: []
  tags:
    - deploy_linux_bridges

- name: Build unique linux_bridges by name (deduplicate duplicates from host_vars)
  set_fact:
    linux_bridges_unique: "{{ linux_bridges_unique + [ item ] }}"
  loop: "{{ linux_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  when: "(linux_bridges_unique | map(attribute='name') | list).count(item.name) == 0"
  tags:
    - deploy_linux_bridges

# OVS flow (simplified)
# - Build the `ovs_bridge_block` from `ovs_bridges` facts.
# - Remove any duplicate Linux bridge stanzas for interfaces that will be
#   managed by OVS (so there's no conflict in `/etc/network/interfaces`).
- name: Build OVS /etc/network/interfaces block
  set_fact:
    ovs_bridge_block: "{{ lookup('template', playbook_dir + '/../../roles/network_provision/templates/ovs_bridges.j2') }}"
  when: ovs_bridges | length > 0
  changed_when: false
  tags:
    - deploy_ovs_bridges

- name: Remove existing Linux bridge stanzas for OVS-named bridges
  become: true
  shell: |
    for br in {{ ovs_bridges | map(attribute='name') | join(' ') }}; do
      perl -0777 -i -pe "s/\nauto ${br}[\\s\\S]*?(?=\nauto |\n# BEGIN |\nsource )//g" /etc/network/interfaces || true
    done
  when: ovs_bridges | length > 0
  tags:
    - deploy_ovs_bridges

- name: Normalize any existing OVS blocks and ensure spacing between iface stanzas
  include_tasks: normalize_ovs.yml
  # Normalization is intentionally a separate, included task file so both
  # flows share the same backing logic and safety checks.
  tags:
    - deploy_ovs_bridges

- name: Insert OVS block into /etc/network/interfaces (above source include)
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} OVS BRIDGES"
    block: "{{ ovs_bridge_block }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  notify: reload_network
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Show OVS bridge block (no host edits)
  debug:
    msg: "{{ ovs_bridge_block }}"
  when: (ovs_bridges | length > 0) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Create OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-br {{ item.name }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0)
  tags:
    - deploy_ovs_bridges

- name: Add ports to OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-port {{ item.name }} {{ item.interface }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.interface is defined and item.interface != '')
  tags:
    - deploy_ovs_bridges

- name: Set OVS port MTU (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl set Interface {{ item.interface }} mtu_request={{ item.mtu }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.mtu is defined and item.mtu | int > 0) and (item.interface is defined and item.interface != '')
  tags:
    - deploy_ovs_bridges

### Linux bridge tasks (tag: deploy_linux_bridges)

# Discover Proxmox node id and existing network objects so we can be idempotent
- name: Get Proxmox nodes (for node id resolution)
  become: true
  command: pvesh --noproxy get /nodes --output-format json
  register: pvesh_nodes_raw
  changed_when: false
  tags:
    - deploy_linux_bridges

- name: Set pve_node_id (first node)
  set_fact:
    pve_node_id: "{{ (pvesh_nodes_raw.stdout | from_json)[0].node }}"
  when: pvesh_nodes_raw.stdout is defined and (pvesh_nodes_raw.stdout | default('') | trim) != ''
  tags:
    - deploy_linux_bridges

- name: Get existing network objects for node
  become: true
  command: "pvesh --noproxy get /nodes/{{ pve_node_id }}/network --output-format json"
  register: pvesh_networks_raw
  changed_when: false
  when: pve_node_id is defined
  tags:
    - deploy_linux_bridges

- name: Set existing_ifaces list
  set_fact:
    existing_networks: "{{ pvesh_networks_raw.stdout | default('[]') | from_json }}"
    existing_ifaces: "{{ (pvesh_networks_raw.stdout | default('[]') | from_json) | map(attribute='iface') | list }}"
  when: pvesh_networks_raw is defined
  tags:
    - deploy_linux_bridges
