---
# PVE 9 SDN Bridge Configuration using Proxmox API
# Fixed bridge assignments for hybrid spine-leaf architecture (1 interface per bridge)
# - vmbr99: Management Bridge (first available 10Gb interface)
# - vmbr2: External Bridge (second 10Gb interface if available, otherwise first 1Gb interface)
# - vmbr1: VM Bridge (third 10Gb interface if available, otherwise next available 1Gb interface)
#
# Optional reboot and verification:
# Set provision_reboot_after_config=true to automatically reboot and verify network status
# Example: ansible-playbook ... -e provision_reboot_after_config=true

# Build fixed bridge assignments based on normalized interface names
# Limit to 1 interface per bridge to avoid STP issues
# Priority order for 10GbE: vmbr99 > vmbr2 > vmbr1

- name: Verify required variables are set before proceeding with bridge configuration
  assert:
    that:
      - nic_names is defined
      - protected_mgmt_iface is defined
      - eth_norm is defined
    fail_msg: "Required variables not set. Please run discovery and naming tasks first."

- name: Debug protected management interface
  debug:
    msg: "Protected management interface: {{ protected_mgmt_iface }}"
  when: protected_mgmt_iface is defined

- name: Calculate available 10GbE interfaces (excluding protected)
  set_fact:
    available_10gbe: "{{ nic_names | dict2items | selectattr('value','match','^xg') | map(attribute='key') | select('ne', protected_mgmt_iface) | list }}"

- name: Get normalized names for available 10GbE interfaces
  set_fact:
    available_10gbe_norm: "{{ available_10gbe | map('extract', nic_names) | list }}"

- name: Assign 10GbE interfaces by priority order
  set_fact:
    bridge_assignments:
      vmbr99: "{{ [available_10gbe_norm[0]] if available_10gbe_norm | length > 0 else [] }}"  # Highest priority 10GbE
      vmbr2: "{{ [available_10gbe_norm[1]] if available_10gbe_norm | length > 1 else [] }}"  # Second priority 10GbE
      vmbr1: "{{ [available_10gbe_norm[2]] if available_10gbe_norm | length > 2 else [] }}"  # Third priority 10GbE

- name: Fill 1GbE fallbacks for bridges without 10GbE
  set_fact:
    # Separate eth interfaces from other interfaces and sort eth numerically
    eth_interfaces: "{{ interfaces | select('match', '^eth[0-9]+$') | sort }}"
    other_interfaces: "{{ interfaces | reject('match', '^eth[0-9]+$') | list }}"
    bridges_needing_fallback: "{{ bridge_assignments | dict2items | selectattr('value', 'equalto', []) | map(attribute='key') | list }}"

- name: Create prioritized interface list for fallback assignments
  set_fact:
    # Prioritize eth interfaces first, then other interfaces
    prioritized_interfaces: "{{ eth_interfaces + other_interfaces }}"

- name: Assign fallback interfaces to bridges needing them
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({item.0: [item.1]}) }}"
  loop: "{{ bridges_needing_fallback | zip(prioritized_interfaces) | list }}"
  when: bridges_needing_fallback | length > 0 and prioritized_interfaces | length > 0

# Ensure protected management interface is not assigned to any bridge
- name: Ensure protected management interface is not assigned to any bridge
  set_fact:
    bridge_assignments: "{{ bridge_assignments | combine({item.key: item.value | reject('equalto', protected_mgmt_iface)}) }}"
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}"

# Validate bridge assignments - ensure exactly 1 interface per bridge
- name: Validate bridge assignments - ensure exactly 1 interface per bridge
  assert:
    that: item.value | length == 1
    fail_msg: "Bridge {{ item.key }} has {{ item.value | length }} interfaces assigned, but exactly 1 interface per bridge is required for SDN stability"
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}: {{ item.value }}"
  when: item.key != 'vmbr0'

# Validate no interface conflicts - ensure each interface is assigned to exactly 1 bridge
- name: Validate no interface conflicts - ensure each interface is assigned to exactly 1 bridge
  set_fact:
    all_assigned_interfaces: "{{ bridge_assignments | dict2items | selectattr('key', 'ne', 'vmbr0') | map(attribute='value') | flatten | list }}"
  when: bridge_assignments is defined

- name: Check for interface conflicts
  assert:
    that: (all_assigned_interfaces | count) == (all_assigned_interfaces | unique | count)
    fail_msg: "Interface conflict detected: {{ all_assigned_interfaces | difference(all_assigned_interfaces | unique) | join(', ') }} are assigned to multiple bridges. Each interface must be assigned to exactly 1 bridge."
  when: all_assigned_interfaces is defined

# Debug bridge assignments before assertion
- name: Debug bridge assignments before assertion
  debug:
    msg: "Bridge assignments: {{ bridge_assignments }}"

# Pause for confirmation before applying assignments (if requested)
- name: Pause for confirmation before applying assignments
  pause:
    prompt: "Proceed to apply bridge assignments? (press Enter to continue or CTRL-C to abort)"
  when: provision_confirm_before_apply | default(false) and not (provision_generate_only | default(false))

# Get current Proxmox network configuration
- name: Get current Proxmox network configuration
  become: true
  command: pvesh get /nodes/localhost/network --output-format json
  register: proxmox_network_config
  changed_when: false
  when: not (provision_generate_only | default(false))
  check_mode: no

# Parse existing network interfaces
- name: Parse existing network interfaces
  set_fact:
    existing_interfaces: "{{ proxmox_network_config.stdout | from_json | map(attribute='iface') | list }}"
  when: not (provision_generate_only | default(false)) and proxmox_network_config.stdout is defined
  check_mode: no

# Create or update bridges using Proxmox API
- name: Create or update bridges using Proxmox API
  become: true
  when: not (provision_generate_only | default(false))
  loop: "{{ bridge_assignments | dict2items }}"
  loop_control:
    label: "{{ item.key }}"
  vars:
    bridge_name: "{{ item.key }}"
    bridge_ports: "{{ item.value | join(',') }}"
  command: |
    bash -c "
    if /usr/bin/jq -r '.[].iface' < <(pvesh get /nodes/localhost/network --output-format json) | grep -q '^\\b{{ bridge_name }}\\b$'; then
      pvesh set /nodes/localhost/network/{{ bridge_name }} -type bridge -bridge_ports '{{ bridge_ports }}' -bridge_vlan_aware yes -autostart yes
    else
      pvesh create /nodes/localhost/network -iface {{ bridge_name }} -type bridge -bridge_ports '{{ bridge_ports }}' -bridge_vlan_aware yes -autostart yes
    fi
    "

# Ensure interfaces referenced in bridges are declared
- name: Ensure interfaces referenced in bridges are declared
  become: true
  when: not (provision_generate_only | default(false))
  loop: "{{ bridge_assignments | dict2items | subelements('value') }}"
  loop_control:
    label: "{{ item.1 }}"
  vars:
    iface: "{{ item.1 }}"
  command: |
    bash -c "
    if ! /usr/bin/jq -r '.[].iface' < <(pvesh get /nodes/localhost/network --output-format json) | grep -q '^\\b{{ iface }}\\b$'; then
      pvesh create /nodes/localhost/network -iface {{ iface }} -type eth
    fi
    "

# Reload network configuration through Proxmox API
- name: Reload network configuration
  become: true
  when: not (provision_generate_only | default(false))
  command: pvesh set /nodes/localhost/network
  changed_when: true
  register: network_reload_result

# Summary - show final state for bridges
- name: Summary - show final state for bridges
  shell: ip -br link show type bridge || true
  register: bridges_state
  changed_when: false

- name: Show bridges state
  debug:
    var: bridges_state.stdout_lines

- name: Show Proxmox network configuration
  become: true
  command: pvesh get /nodes/localhost/network
  register: final_proxmox_config
  changed_when: false

- name: Display final Proxmox network configuration
  debug:
    msg: "{{ final_proxmox_config.stdout_lines | join('\n') }}"

# Optional reboot and verification (controlled by variable)
- name: Reboot system to apply network changes
  reboot:
    reboot_timeout: 300
    msg: "Rebooting system to apply network configuration changes"
  when: provision_reboot_after_config | default(false)
  register: reboot_result

- name: Wait for system to stabilize after reboot
  command: sleep 160
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Verify bridges are active after reboot
  command: ip -br link show type bridge
  register: post_reboot_bridges
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Verify Proxmox network configuration after reboot
  become: true
  command: pvesh get /nodes/localhost/network
  register: post_reboot_config
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
  changed_when: false

- name: Display post-reboot verification results
  debug:
    msg: |
      === Post-Reboot Network Verification ===
      Bridge Status:
      {{ post_reboot_bridges.stdout_lines | join('\n') }}

      Proxmox Network Configuration:
      {{ post_reboot_config.stdout_lines | join('\n') }}

      âœ… Network configuration successfully applied and verified after reboot!
  when: provision_reboot_after_config | default(false) and reboot_result is defined and reboot_result.changed
