---
# Very small OVS-only bridging tasks
# - Renders a single persistent OVS block for /etc/network/interfaces
# - Excludes vmbr2 (managed separately as a Linux bridge)
# - No runtime `ovs-vsctl` or `pvesh` operations here

- name: Load host bridge definitions
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/bridges.yml"
    name: host_bridges
  ignore_errors: true
  tags: [deploy_ovs_bridges]

- name: Compute OVS bridges (merge host + role, exclude vmbr2)
  set_fact:
    ovs_bridges: >-
      {{ ((host_bridges.bridges | default([])) + (bridges | default([])))
         | selectattr('type','defined') | selectattr('type','equalto','ovs')
         | rejectattr('name','equalto','vmbr2') | list }}
  tags: [deploy_ovs_bridges]

- name: Render persistent OVS block via template
  set_fact:
    ovs_bridge_block: "{{ lookup('template', playbook_dir + '/../../roles/network_provision/templates/ovs_bridges.j2') }}"
  when: ovs_bridges | length > 0
  changed_when: false
  tags: [deploy_ovs_bridges]

- name: Insert OVS block into /etc/network/interfaces (persistent only)
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} OVS BRIDGES"
    block: "{{ ovs_bridge_block }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags: [deploy_ovs_bridges]

- name: Preview OVS block (no write)
  debug:
    msg: "{{ ovs_bridge_block }}"
  when: (ovs_bridges | length > 0) and not (write_interfaces_file | default(false))
  tags: [deploy_ovs_bridges]
# Minimal OVS-only bridging tasks
# - Purpose: emit persistent /etc/network/interfaces OVS block only.
# - Behavior: build a single, non-duplicated `# BEGIN OVS BRIDGES`..`# END OVS BRIDGES`
#   block that lists physical ports as OVSPort stanzas and OVSBridge stanzas that
#   include pre-associated vxlan logical names in the `ovs_ports` line.
# - Important: This task file will NOT run any runtime `ovs-vsctl` or `pvesh`
---
# Simplified bridging tasks (single-file orchestration)
#
# Purpose
# - Provide a compact flow for rendering and (optionally) applying both OVS
#   and Linux bridge configuration for a single host.
#
# Notes for junior engineers
# - This file mirrors the main `bridging.yml` flow but keeps the tasks
#   simpler and more explicit for quick runs. It still delegates normalization
#   to `normalize_ovs.yml` and prefers Proxmox `pvesh` for Linux bridge actions.
#   commands. Runtime VXLAN creation must be performed separately (see
#   `import/ovs-vxlan-prompt.md`). vmbr2 is intentionally excluded from the
#   generated OVS block and should be managed separately as a Linux bridge.

- name: Load host-specific OVS vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/bridges.yml"
    name: ovs_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - name: Merge bridges from host vars and role/group `bridges`
      set_fact:
        merged_bridges: >-
          {{ (ovs_host_vars.bridges | default([])) + (bridges | default([])) }}
      tags:
        - deploy_ovs_bridges
    - name: Normalize each bridge entry and select only OVS bridges (exclude vmbr2)
      set_fact:
        ovs_bridges: >-
        {{ (merged_bridges | default([]))
         | map('combine', {
           'ports': (item.ports | default(item.bridge_ports | default([]))),
                 'interface': ((item.ports | default(item.bridge_ports | default([])))[0] if ((item.ports | default(item.bridge_ports | default([]))) | length > 0) else (item.parent | default(item.interface | default('')))),
                 'type': ( 'ovs' if ('ovs' in (item.type | default('bridge') | string | lower)) else 'bridge')
               })
             | selectattr('type','equalto','ovs')
            ---
            ---
            # Bridging tasks removed â€” this role no longer manages bridging.
            #
            # Per project convention (`import/ovs-vxlan-prompt.md`), OVS bridge
            # persistent configuration and VXLAN runtime provisioning are separated.
            # Use the `ovs_vxlan_provision` role to perform OVS/VXLAN runtime actions.

            - name: Inform: bridging tasks moved to `ovs_vxlan_provision`
              debug:
                msg: "Bridging tasks have been removed from `network_provision`. Use the `ovs_vxlan_provision` role for OVS/VXLAN provisioning."
              tags: [deploy_ovs_bridges]
          'ports': (item.ports | default(item.bridge_ports | default([]))),
          'interface': ((item.ports | default(item.bridge_ports | default([])))[0] if ((item.ports | default(item.bridge_ports | default([]))) | length > 0) else (item.parent | default(item.interface | default('')))),
          'type': ( 'ovs' if ('ovs' in (item.type | default('bridge') | string | lower)) else 'bridge' )
        })
      ) ] }}
  loop: "{{ merged_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Split into ovs_bridges and linux_bridges
  set_fact:
    ovs_bridges: "{{ normalized_bridges | selectattr('type','equalto','ovs') | list }}"
    linux_bridges: "{{ normalized_bridges | selectattr('type','equalto','bridge') | list }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize unique linux_bridges list
  set_fact:
    linux_bridges_unique: []
  tags:
    - deploy_linux_bridges

- name: Build unique linux_bridges by name (deduplicate duplicates from host_vars)
  set_fact:
    linux_bridges_unique: "{{ linux_bridges_unique + [ item ] }}"
  loop: "{{ linux_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  when: "(linux_bridges_unique | map(attribute='name') | list).count(item.name) == 0"
  tags:
    - deploy_linux_bridges

# OVS flow (simplified)
# - Build the `ovs_bridge_block` from `ovs_bridges` facts.
# - Remove any duplicate Linux bridge stanzas for interfaces that will be
#   managed by OVS (so there's no conflict in `/etc/network/interfaces`).
- name: Build OVS /etc/network/interfaces block
  set_fact:
    ovs_bridge_block: "{{ lookup('template', playbook_dir + '/../../roles/network_provision/templates/ovs_bridges.j2') }}"
  when: ovs_bridges | length > 0
  changed_when: false
  tags:
    - deploy_ovs_bridges

- name: Remove existing Linux bridge stanzas for OVS-named bridges
  become: true
  shell: |
    for br in {{ ovs_bridges | map(attribute='name') | join(' ') }}; do
      perl -0777 -i -pe "s/\nauto ${br}[\s\S]*?(?=\nauto |\n# BEGIN |\nsource )//g" /etc/network/interfaces || true
    done
  when: ovs_bridges | length > 0
  tags:
    - deploy_ovs_bridges

- name: Normalize any existing OVS blocks and ensure spacing between iface stanzas
  include_tasks: normalize_ovs.yml
  # Normalization is intentionally a separate, included task file so both
  # flows share the same backing logic and safety checks.
  tags:
    - deploy_ovs_bridges

- name: Insert OVS block into /etc/network/interfaces (above source include)
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} OVS BRIDGES"
    block: "{{ ovs_bridge_block }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Validate /etc/network/interfaces after OVS block
  become: true
  command: ifquery --list
  register: ifquery_after_ovs
  failed_when: ifquery_after_ovs.rc != 0
  changed_when: false
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Reload network (ifquery passed)
  become: true
  command: ifreload -a
  when: (ifquery_after_ovs is defined) and (ifquery_after_ovs.rc == 0) and (write_interfaces_file | default(false))
  loop_control:
    label: "{{ item.1.name | default('unnamed') }}"
  when: linux_bridges_unique is defined
  tags:
    - deploy_linux_bridges

- name: Check if subinterface exists in Proxmox
  become: true
  command: >-
    pvesh --noproxy get /nodes/{{ pve_node_id }}/network/{{ item.name }} --output-format json
  register: pvesh_subiface_lookup
  failed_when: false
  changed_when: false
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0)
  tags:
    - deploy_linux_bridges

- name: Validate subinterface iface name for pvesh create
  assert:
    that:
      - "(item.name is match('^[A-Za-z0-9._]+$'))"
    fail_msg: "Invalid subinterface name '{{ item.name }}' for Proxmox API. Rename or adjust the host var before creating via pvesh."
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(0)) != 0)
  tags:
    - deploy_linux_bridges

- name: Create subinterfaces (when missing)
  become: true
  vars:
    # support either nested 'options' key or flat subinterface dict
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    # build flags as single "--flag=value" strings so empty values are never left as a bare flag
    _create_params: >-
      {{ ["--iface=" ~ item.name, "--type=" ~ (item.type | default('vlan'))]
         + (
           (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
         )
         + (
           (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0) ) else [])
         )
         + (
           (['--cidr=' ~ _opts.address])
           if (_opts.address is defined and ('/' in (_opts.address | string)))
           else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else [])
         )
         + (
           (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
         )
      }}
  command: >-
    pvesh --noproxy create /nodes/{{ pve_node_id }}/network {{ _create_params | join(' ') }}
  register: pvesh_subiface_create
  failed_when: false
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(0)) != 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: 'Fallback: reconcile subiface when create failed with "interface already exists"'
  become: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    _set_params: >-
      {{ ["--type=" ~ (item.type | default('vlan'))]
        + (
          (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
        )
        + (
          (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0)) else [])
        )
        + (['--cidr=' ~ _opts.address] if (_opts.address is defined and ('/' in (_opts.address | string))) else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else []))
        + (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_subiface_create_fallback_result
  failed_when: false
  when: >-
    pve_node_id is defined and
    (pvesh_subiface_create is defined) and
    ((pvesh_subiface_create.results[sub_idx].rc | default(0)) != 0) and
    ("interface already exists" in (pvesh_subiface_create.results[sub_idx].stderr | default(''))) and
    (_set_params | length > 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: Set subinterfaces (update existing when diffs)
  become: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _vxlan_id: "{{ _opts.id | default(_opts.vni | default(None)) }}"
    _is_vxlan: "{{ (item.type | default('vlan')) == 'vxlan' }}"
    _set_params: >-
      {{ []
        + (
          (["--id=" ~ (_vxlan_id|string)] if (_is_vxlan and _vxlan_id is defined and _vxlan_id is not none and (_vxlan_id|string) | length > 0) else [])
        )
        + (
          (["--vlan-id=" ~ (_vlan_id|string), "--vlan-raw-device=" ~ _vlan_raw] if (not _is_vxlan and _vlan_id is defined and _vlan_id is not none and (_vlan_id|string) | length > 0 and (_vlan_raw is defined and _vlan_raw | length > 0)) else [])
        )
        + (['--cidr=' ~ _opts.address] if (_opts.address is defined and ('/' in (_opts.address | string))) else (['--address=' ~ _opts.address] if (_opts.address is defined and (_opts.address | string) | length > 0) else []))
        + (['--mtu=' ~ (_opts.mtu|string)] if (_opts.mtu is defined and (_opts.mtu|string) | length > 0) else [])
      }}
  command: >-
    pvesh --noproxy set /nodes/{{ pve_node_id }}/network/{{ item.name }} {{ _set_params | join(' ') }}
  register: pvesh_subiface_set
  failed_when: false
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(1)) == 0) and (_set_params | length > 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

- name: Record no-op for subinterfaces that already match desired state
  set_fact:
    pvesh_subiface_noop: true
  vars:
    _opts: "{{ (item.options.options | default(item.options)) | default({}) }}"
    _vlan_id: "{{ _opts['vlan-id'] | default(_opts.vlan_id | default(_opts.tag | default(None))) }}"
    _vlan_raw: "{{ _opts['vlan-raw-device'] | default(_opts.vlan_raw_device | default(_opts['raw-device'] | default(_opts.raw_device | default(item.parent)))) }}"
    _set_params: >-
      {{ []
        + (['--vlan-id', _vlan_id|string] if (_vlan_id is defined and _vlan_id is not none) else [])
        + (['--vlan-raw-device', _vlan_raw] if (_vlan_raw is defined and _vlan_raw | length > 0) else [])
        + (['--address', _opts.address] if (_opts.address is defined) else [])
      }}
  when: pve_node_id is defined and (bridge_subinterfaces | length > 0) and (pvesh_subiface_lookup is defined and (pvesh_subiface_lookup.results[sub_idx].rc | default(1)) == 0) and (_set_params | length == 0)
  loop: "{{ bridge_subinterfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
    index_var: sub_idx
  tags:
    - deploy_linux_bridges

# Ensure source directive and validate
- name: Ensure source directive at end of interfaces
  become: true
  lineinfile:
    path: /etc/network/interfaces
    line: "source /etc/network/interfaces.d/*"
    insertafter: EOF

# Fallback: write /etc/network/interfaces.d/<iface>.cfg when pvesh not available
# or when explicitly requested by write_interfaces_file.
- name: Write Linux bridge interface files (fallback)
  become: true
  vars:
    bridge: "{{ item }}"
  template:
    src: linux_bridges_interfaces.j2
    dest: "/etc/network/interfaces.d/{{ item.name }}.cfg"
    owner: root
    group: root
    mode: '0644'
  # notify: reload_network
  loop: "{{ (linux_bridges_unique | default(linux_bridges) | default([])) }}"
  loop_control:
    label: "{{ item.name }}"
  # only write fallback interface files when explicitly requested, when we have
  # a resolved pve_node_id (to avoid accidental writes in check-mode or when
  # pvesh is unavailable), and not when Ansible is running in check mode.
  when: (write_interfaces_file | default(false)) and (pve_node_id is defined) and (not (ansible_check_mode | default(false)))
  tags:
    - deploy_linux_bridges

- name: Validate /etc/network/interfaces via ifquery
  command: ifquery --list
  register: ifquery_result
  failed_when: ifquery_result.rc != 0
  changed_when: false

- name: Include glue tasks (create veth glue between Linux and OVS bridges)
  include_tasks: establish_glue.yml
  tags:
    - establish_glue

---
# Simplified bridging tasks (single-file orchestration)
#
# Purpose
# - Provide a compact flow for rendering and (optionally) applying both OVS
#   and Linux bridge configuration for a single host.
#
# Notes for junior engineers
# - This file mirrors the main `bridging.yml` flow but keeps the tasks
#   simpler and more explicit for quick runs. It still delegates normalization
#   to `normalize_ovs.yml` and prefers Proxmox `pvesh` for Linux bridge actions.

- name: Load host-specific OVS vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/bridges.yml"
    name: ovs_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Load host-specific network vars (if any)
  include_vars:
    file: "{{ playbook_dir }}/../../host_vars/{{ inventory_hostname }}/network.yml"
    name: net_host_vars
  ignore_errors: true
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Merge bridges from host vars and role/group `bridges`
  set_fact:
    merged_bridges: >-
      {{ (ovs_host_vars.bridges | default([])) + (net_host_vars.bridges | default([])) + (bridges | default([])) }}
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize normalized_bridges
  set_fact:
    normalized_bridges: []
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Normalize each bridge entry (interface and type)
  set_fact:
    normalized_bridges: >-
      {{ normalized_bridges + [ (
        item | combine({
          'ports': (item.ports | default(item.bridge_ports | default([]))),
          'interface': ((item.ports | default(item.bridge_ports | default([])))[0] if ((item.ports | default(item.bridge_ports | default([]))) | length > 0) else (item.parent | default(item.interface | default('')))),
          'type': ( 'ovs' if ('ovs' in (item.type | default('bridge') | string | lower)) else 'bridge' )
        })
      ) ] }}
  loop: "{{ merged_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Split into ovs_bridges and linux_bridges
  set_fact:
    ovs_bridges: "{{ normalized_bridges | selectattr('type','equalto','ovs') | list }}"
    linux_bridges: "{{ normalized_bridges | selectattr('type','equalto','bridge') | list }}"
  tags:
    - deploy_ovs_bridges
    - deploy_linux_bridges

- name: Initialize unique linux_bridges list
  set_fact:
    linux_bridges_unique: []
  tags:
    - deploy_linux_bridges

- name: Build unique linux_bridges by name (deduplicate duplicates from host_vars)
  set_fact:
    linux_bridges_unique: "{{ linux_bridges_unique + [ item ] }}"
  loop: "{{ linux_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name | default('unnamed') }}"
  when: "(linux_bridges_unique | map(attribute='name') | list).count(item.name) == 0"
  tags:
    - deploy_linux_bridges

# OVS flow (simplified)
# - Build the `ovs_bridge_block` from `ovs_bridges` facts.
# - Remove any duplicate Linux bridge stanzas for interfaces that will be
#   managed by OVS (so there's no conflict in `/etc/network/interfaces`).
- name: Build OVS /etc/network/interfaces block
  set_fact:
    ovs_bridge_block: "{{ lookup('template', playbook_dir + '/../../roles/network_provision/templates/ovs_bridges.j2') }}"
  when: ovs_bridges | length > 0
  changed_when: false
  tags:
    - deploy_ovs_bridges

- name: Remove existing Linux bridge stanzas for OVS-named bridges
  become: true
  shell: |
    for br in {{ ovs_bridges | map(attribute='name') | join(' ') }}; do
      perl -0777 -i -pe "s/\nauto ${br}[\\s\\S]*?(?=\nauto |\n# BEGIN |\nsource )//g" /etc/network/interfaces || true
    done
  when: ovs_bridges | length > 0
  tags:
    - deploy_ovs_bridges

- name: Normalize any existing OVS blocks and ensure spacing between iface stanzas
  include_tasks: normalize_ovs.yml
  # Normalization is intentionally a separate, included task file so both
  # flows share the same backing logic and safety checks.
  tags:
    - deploy_ovs_bridges

- name: Insert OVS block into /etc/network/interfaces (above source include)
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} OVS BRIDGES"
    block: "{{ ovs_bridge_block }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  # notify: reload_network
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Flush handlers after inserting OVS block (run reload if notified)
  # meta: flush_handlers
  when: (ovs_bridges | length > 0) and (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Show OVS bridge block (no host edits)
  debug:
    msg: "{{ ovs_bridge_block }}"
  when: (ovs_bridges | length > 0) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Create OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-br {{ item.name }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and not (ansible_check_mode | default(false)) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Add ports to OVS bridges (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl --may-exist add-port {{ item.name }} {{ item.interface }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.interface is defined and item.interface != '') and not (ansible_check_mode | default(false)) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

- name: Set OVS port MTU (live) when requested
  become: true
  command: "/usr/bin/ovs-vsctl set Interface {{ item.interface }} mtu_request={{ item.mtu }}"
  loop: "{{ ovs_bridges | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: (ovs_create | default(false)) and (ovs_bridges | length > 0) and (item.mtu is defined and item.mtu | int > 0) and (item.interface is defined and item.interface != '') and not (ansible_check_mode | default(false)) and not (write_interfaces_file | default(false))
  tags:
    - deploy_ovs_bridges

### Linux bridge tasks (tag: deploy_linux_bridges)

# Discover Proxmox node id and existing network objects so we can be idempotent
- name: Get Proxmox nodes (for node id resolution)
  become: true
  command: pvesh --noproxy get /nodes --output-format json
  register: pvesh_nodes_raw
  changed_when: false
  tags:
    - deploy_linux_bridges

- name: Set pve_node_id (first node)
  set_fact:
    pve_node_id: "{{ (pvesh_nodes_raw.stdout | from_json)[0].node }}"
  when: pvesh_nodes_raw.stdout is defined and (pvesh_nodes_raw.stdout | default('') | trim) != ''
  tags:
    - deploy_linux_bridges

- name: Get existing network objects for node
  become: true
  command: "pvesh --noproxy get /nodes/{{ pve_node_id }}/network --output-format json"
  register: pvesh_networks_raw
  changed_when: false
  when: pve_node_id is defined
  tags:
    - deploy_linux_bridges

- name: Set existing_ifaces list
  set_fact:
    existing_networks: "{{ pvesh_networks_raw.stdout | default('[]') | from_json }}"
    existing_ifaces: "{{ (pvesh_networks_raw.stdout | default('[]') | from_json) | map(attribute='iface') | list }}"
  when: pvesh_networks_raw is defined
  tags:
    - deploy_linux_bridges
