# Ansible task file for provisioning Linux and OVS bridges, subinterfaces, and VRF routes on Proxmox SDN nodes.
# This playbook is idempotent and host_vars-driven. All config is rendered from templates and validated before apply.

# --- Pre-flight: Validate physical interfaces ---
- name: Gather all parent interfaces from bridges
  set_fact:
    all_parent_interfaces: >-
      {{ bridges | map(attribute='parent') | select('defined') | list }}

- name: Check all required physical interfaces exist
  command: ip link show {{ item }}
  loop: "{{ all_parent_interfaces }}"
  register: phys_if_check
  failed_when: >-
    phys_if_check is failed or
    (
      (phys_if_check.results is defined and (phys_if_check.results | selectattr('rc', 'ne', 0) | list | length > 0)) or
      (phys_if_check.results is not defined and phys_if_check.rc is defined and phys_if_check.rc != 0)
    )
  changed_when: false

# --- Normalize and partition bridge data ---
- name: Normalize bridges
  set_fact:
    normalized_bridges: "{{ bridges }}"

- name: Initialize normalized_subinterfaces
  set_fact:
    normalized_subinterfaces: []

- name: Flatten subinterfaces and annotate with parent_bridge
  set_fact:
    normalized_subinterfaces: "{{ normalized_subinterfaces + [item.1 | combine({'parent_bridge': item.0.name})] }}"
  with_subelements:
    - "{{ normalized_bridges }}"
    - subinterfaces
    - skip_missing: True
  when: item.1 is defined

- name: Partition bridges and subinterfaces
  set_fact:
    ovs_bridges: "{{ normalized_bridges | selectattr('type', 'equalto', 'OVSBridge') | list }}"
    manual_subinterfaces: "{{ normalized_subinterfaces | selectattr('type', 'in', ['vlan', 'vxlan']) | list }}"
    linux_bridges: "{{ normalized_bridges | selectattr('type', 'equalto', 'Bridge') | list }}"

# --- VRF and routing table handling ---
- name: Ensure all VRFs have routing table entries
  become: true
  lineinfile:
    path: /etc/iproute2/rt_tables
    line: "{{ item.value }} {{ item.key }}"
    state: present
    create: yes
  loop: "{{ vrf_mappings | dict2items }}"
  loop_control:
    label: "{{ item.key }}"
  changed_when: false

- name: Ensure VRF devices exist and have expected table assignment
  include_tasks: vrf_device.yml
  loop: "{{ vrf_mappings | dict2items }}"
  loop_control:
    label: "{{ item.key }}"

# --- Linux bridge configuration ---
- name: Generate Linux bridge stanzas from template
  set_fact:
    linux_bridge_stanzas: "{{ lookup('template', 'linux-bridges.j2') }}"
  when: linux_bridges | length > 0

- name: Assert Linux bridge stanzas exist when linux bridges defined
  assert:
    that:
      - linux_bridge_stanzas is defined
      - linux_bridge_stanzas | trim | length > 0
    fail_msg: "linux_bridges are defined but linux_bridge_stanzas is empty. Define your host_vars or fix linux-bridges.j2 template."
  when: linux_bridges | length > 0

- name: Insert Linux bridge stanzas into /etc/network/interfaces
  become: true
  blockinfile:
    path: /etc/network/interfaces
    marker: "# {mark} LINUX BRIDGES"
    block: "{{ linux_bridge_stanzas }}"
    insertbefore: '^source /etc/network/interfaces.d/*'
  when: linux_bridges | length > 0
  register: linux_bridges_insert_result

# --- Manual subinterface configuration ---
- name: Collect manual subinterface snippets
  set_fact:
    manual_snippets: []

- name: Add manual subinterface snippet for each subinterface not on a Linux bridge
  set_fact:
    manual_snippets: "{{ manual_snippets + [lookup('template', 'subinterface_manual_snippet.j2')] }}"
  loop: "{{ manual_subinterfaces }}"
  loop_control:
    loop_var: sub
  when: "sub.parent_bridge not in (linux_bridge_names | default([]))"

- name: Backup /etc/network/interfaces before changes
  become: true
  copy:
    src: /etc/network/interfaces
    dest: /etc/network/interfaces.bak
    remote_src: true

- name: Deploy manual subinterface config to /etc/network/interfaces.d/manual-sdn.cfg
  become: true
  copy:
    content: "{{ manual_snippets | join('\n\n') }}\n"
    dest: /etc/network/interfaces.d/manual-sdn.cfg
  notify: reload_network
  register: manual_cfg_result

# --- VRF device and route setup ---
#
# This section is now fully templated. All VRF names, table numbers, and subnets should be defined in host_vars or group_vars.
# Example host_vars:
#   vrf_name: vrf_zone1
#   vrf_table: 100
#   vrf_routes:
#     - { subnet: 172.16.11.0/24, dev: vmbr2.11 }
#     - { subnet: 10.10.31.0/24, dev: vxlan_vx10031 }
#     ...

- name: Add static routes to VRF (if any)
  become: true
  command: ip route add table {{ vrf_name }} {{ item.subnet }} dev {{ item.dev }}
  loop: "{{ vrf_routes | default([]) }}"
  ignore_errors: yes
  when: vrf_routes is defined and vrf_routes | length > 0

- name: Ensure IP routing table entry for VRF exists
  become: true
  lineinfile:
    path: /etc/iproute2/rt_tables
    line: "{{ vrf_table }} {{ vrf_name }}"
    state: present
    create: yes
  changed_when: false
  when: vrf_name is defined and vrf_table is defined

- name: Check if VRF device exists
  become: true
  command: ip -d link show {{ vrf_name }}
  register: vrf_check
  failed_when: false
  changed_when: false
  when: vrf_name is defined

  become: true
  command: ip link add {{ vrf_name }} type vrf table {{ vrf_table }}
  when: vrf_name is defined and vrf_table is defined and vrf_check.rc != 0
  register: vrf_create_result
  failed_when: false
  changed_when: vrf_create_result.rc == 0

  become: true
  command: ip link set dev {{ vrf_name }} up
  when: vrf_name is defined and (vrf_check.rc != 0 or (vrf_check is defined and 'state DOWN' in (vrf_check.stdout | default(''))))
  failed_when: false
  changed_when: false

- name: Create VRF device if missing
  become: true
  command: ip link add {{ vrf_name }} type vrf table {{ vrf_table }}
  when: vrf_name is defined and vrf_table is defined and vrf_check.rc != 0
  register: vrf_create_result
  failed_when: false
  changed_when: vrf_create_result.rc == 0

- name: Bring VRF device up if it is down
  become: true
  command: ip link set dev {{ vrf_name }} up
  when: vrf_name is defined and (vrf_check.rc != 0 or (vrf_check is defined and 'state DOWN' in (vrf_check.stdout | default(''))))
  failed_when: false
  changed_when: false

# --- Post-apply validation and cleanup ---
- name: Show all bridges for verification
  command: ip -br link show type bridge
  register: bridge_summary_result

# - name: Debug: print bridge summary
#   debug:
#     msg: "Bridge summary: {{ bridge_summary_result.stdout_lines }}"

- name: Ensure source directive at end of interfaces (final)
  become: true
  lineinfile:
    path: /etc/network/interfaces
    line: "source /etc/network/interfaces.d/*"
    insertafter: EOF

- name: Validate /etc/network/interfaces syntax with ifquery
  command: ifquery --list
  register: ifquery_result
  failed_when: ifquery_result.rc != 0
  changed_when: false
